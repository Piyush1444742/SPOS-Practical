import java.util.Scanner; 
// sjf_preemptive

class Main { 
    public static void main(String args[]) { 
        Scanner s = new Scanner(System.in); 
        int n, i, j, smallest, count = 0, time; 
        float avg_wait = 0, avg_tat = 0, end; 

        System.out.print("Enter number of processes: "); 
        n = s.nextInt(); 

        int process[] = new int[n]; 
        int arrival_time[] = new int[n]; 
        int burst_time[] = new int[n]; 
        int remaining_time[] = new int[n]; 
        int waiting_time[] = new int[n]; 
        int tat[] = new int[n]; 
        int completion_time[] = new int[n]; 

        // Input Burst and Arrival times
        System.out.println("\nEnter Arrival Time and Burst Time for each process:");
        for (i = 0; i < n; i++) { 
            System.out.print("\nProcess[" + (i + 1) + "] Arrival Time: "); 
            arrival_time[i] = s.nextInt(); 
            System.out.print("Process[" + (i + 1) + "] Burst Time: "); 
            burst_time[i] = s.nextInt(); 
            remaining_time[i] = burst_time[i]; 
            process[i] = i + 1; 
        } 

        // --- SJF Preemptive (SRTF) Logic ---
        int complete = 0; 
        int shortest = 0; 
        int min_remaining = Integer.MAX_VALUE; 
        boolean check = false; 
        time = 0; 

        while (complete != n) { 
            // Find process with minimum remaining time among those that have arrived
            for (j = 0; j < n; j++) { 
                if ((arrival_time[j] <= time) && (remaining_time[j] < min_remaining) && remaining_time[j] > 0) { 
                    min_remaining = remaining_time[j]; 
                    shortest = j; 
                    check = true; 
                } 
            } 

            if (check == false) { 
                time++; 
                continue; 
            } 

            // Process execution for 1 unit of time
            remaining_time[shortest]--; 
            min_remaining = remaining_time[shortest]; 
            if (min_remaining == 0) 
                min_remaining = Integer.MAX_VALUE; 

            // If a process is completely executed
            if (remaining_time[shortest] == 0) { 
                complete++; 
                check = false; 
                end = time + 1; 
                completion_time[shortest] = (int) end; 
                waiting_time[shortest] = (int)(end - burst_time[shortest] - arrival_time[shortest]); 

                if (waiting_time[shortest] < 0) 
                    waiting_time[shortest] = 0; 
            } 
            time++; 
        } 

        // Turnaround Time Calculation
        for (i = 0; i < n; i++) { 
            tat[i] = burst_time[i] + waiting_time[i]; 
        } 

        // Calculate Averages
        for (i = 0; i < n; i++) { 
            avg_wait += waiting_time[i]; 
            avg_tat += tat[i]; 
        } 
        avg_wait /= n; 
        avg_tat /= n; 

        // --- Display Results ---
        System.out.println("\nProcess\tArrival\tBurst\tCompletion\tWaiting\tTurnaround"); 
        for (i = 0; i < n; i++) { 
            System.out.println("p" + process[i] + "\t" + arrival_time[i] + "\t" + burst_time[i] + "\t" 
                    + completion_time[i] + "\t\t" + waiting_time[i] + "\t" + tat[i]); 
        } 

        System.out.printf("\nAverage Waiting Time: %.2f", avg_wait); 
        System.out.printf("\nAverage Turnaround Time: %.2f\n", avg_tat); 

        s.close(); 
    } 
}
